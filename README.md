# README

This repository demonstrates a compatibility issue with Kubernetes API server certificates generated by different versions of kubeadm, specifically regarding the handling of the Authority Key Identifier (AKI) and Subject Key Identifier (SKI) fields. It provides scripts and a patch to reproduce and analyze the problem, showing how certificates generated by older kubeadm versions can cause TLS verification failures in newer Python clients (e.g., Python 3.13). The repo includes tools to build patched kubeadm binaries, generate test certificates, and run a minimal server and client to observe the effects of the certificate differences in practice.

Amazon EKS is [tracking the resolution for this issue](https://github.com/aws/containers-roadmap/issues/2638) as part of the cluster CA rotation feature. 

## Build

To build kubeadm-patched from source,

```bash
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.33.0
cp $CA_POC_DIR/aki.patch ./
git apply aki.patch
KUBE_BUILD_PLATFORMS=linux/amd64 make WHAT=cmd/kubeadm
cp _output/local/bin/linux/amd64/kubeadm $CA_POC_DIR/kubeadm-patched
```

Check the make file:
```bash
# Download kubeadm 1.16, 1.33
make download-kubeadm

# Generate 1.16 CA, 1.33 CA
# Generates 
# - kubeadm-1.16 API certs against 1.16 CA
# - kubeadm-1.33 API certs against 1.33 CA
# - kubeadm-1.33 API certs aganist 1.16 CA ("mixed" dir)
# - kubeadm-patched API certs against 1.16 CA ("patched-133" dir)
make generate-certs

# You can see the differences in the created API certs
vimdiff ./certs/*/apiserver.crt.txt

# Run the server with the patched-kubeadm generated API certs
make run-server

# see it work with Python 3.12
make run-client-py312

# see it fail with Python 3.13
make run-client-py313 

# Run a Python 3.13 client with ssl option VERIFY_X509_STRICT disabled
make run-client-py313-no-strict
```

This results in a Python 3.13 failure:
```
Error connecting to https://kubernetes/: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: Missing Subject Key Identifier (_ssl.c:1028)>
```

## AI Prompt

> I used the following prompt to Cursor to generate most of this repository

I've got a user with 2 Kubernetes clusters. One was originally created with K8s 1.16, and then upgraded all the way to 1.33, and the other created with 1.33, both using kubeadm to generate the certificate authority for the cluster, and the serving certs for the Kube API servers.

I heard that clusters created with 1.16 has a CA without a `Subject Key Identifier` specified in the CA certificate, and Kube API certs don't have a `Authority Key Identifier` either. 
The clusters created at 1.33 _do_ have the SKI in the CA and an AKI in the KubeAPI certs

I'd like to recreate this behavior using `kubeadm`'s certificate generation. I've downloaded linux kubeadm for each k8s version, `kubeadm-116` and `kubeadm-133`, and am running on a Mac machine. 

I'd like to use docker CLI to run those kubeadm commands in docker containers to create and save an x509 CA and example Kube API server cert for each version.

Can you help me create a shell script that bind mounts the cwd with kubeadm binaries into the container and creates the CA and cert?

## License

MIT License